```javascript
/**
 * 单例设计模式 (singleton pattern)
 * 1、表现形成
 *   var obj = {
 *        xxxx,
 *        ....
 *   }
 *  在单例设计模型中，obj不仅仅是对象名，它被称为”命名空间“【nameSpace】， 把描述事务的属性存放到命名空间中，
 * 多个命名空间是独立分开的，互补冲突
 * 
 * 2、作用
 * => 把描述同一件事务的属性和特征进行”分组、归类“（存储在同一个堆内存空间中），因此
 * 避免了全局变量之间的冲突和污染
 * 
 * var pattern1 = {name: 'xxx'}
 * var pattern2 = {name: 'xxx'}
 * 
 * 3、单例设计模式命名的由来：
 * => 每一个命名空间都是JS中Object这个内置基类的实例，而实例之间互相独立互不干扰，所以我们称它为”单例：单独的实例“
 * 
 */

 /**
  * 高级单例模式
  * 1、在给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域(不销毁的栈内存)。
  * 在AA中创建一个堆内存，把堆内存地址赋值给命名空间
  * 
  * 2、这种模式的好处： 我们完全可以在AA中 创造很多内容(变量OR函数)， 哪些需要供外面调取使用的，我们
  * 暴露到返回的对象中（模块化实现的一种思想）
  */

  var nameSpace = (function() {
    var n = 12
    function fn() {

    }
    return {
      fn: fn
    }
  })();

  /**
   * THIS
   * 1、给当前元素的某个事件绑定方法， 当事件触发方法执行的时候，方法中的this就是当前操作的元素对象
   * oBox.onclick = function() {
   * //=> this: oBox
   * }
   * 
   * 2、普通函数执行，函数中的this取决于执行的主体，谁执行的，this就是谁（执行主体： 方法执行，
   * 看方法名前面是否有”点“， 有的话，点前面的是谁this就是谁，没有this就window）
   * 
   * // 自执行函数，方法中的this是window
   * ~function() {
   *  // => this:window  
   * }()
   */
  var n = 2;
  var obj = {
    n: 3,
    fn: (function(n) {
      n*=2;
      this.n +=2;
      var n = 5;
      return function (m) {
        this.n *=2;
        console.log(m + (++n))
      }
    })(n) // 写成obj.n 会报错  自执行没执行完 obj 还没创建
  }
  var fn = obj.fn;
  fn(3) // 9
  obj.fn(3) // 10
  console.log(n , obj.n) // 8 6


  // 基于单例模式模块化开发
  /**
   * 模块化开发
   *  1、 团队协作开发的时候，会把产品按照功能板块进行划分，每一个功能板块有专人负责开发
   *  2、把各个板块之间公用的部分进行提取封装，后期再想实现这些功能，直接的调取引用即可(模块封装)
   */

   var skipRender = (function (){
     var fn = function() {

     }
     return {
        init: function() {

        },
        fn: fn
     }
   })()
   skipRender.init();

   var weatherRender = (function (){
    var fn = function() {

    }
    return {
       init: function() {
          fn() // =>  调取自己模块中的方法直接调取使用
          skipRender.fn() //=> 调取别人代码的方法
       }
    }
  })()
  weatherRender.init();


/**
* 工厂模式- > 函数
1、把实现相同功能的代码进行”封装“，以此来实现”批量生产“(后期想要实现这个功能，我们只需要执行函数即可)
2、”低耦合高内聚“：减少页面中冗余代码，提高代码的重复使用率
*/
function createPerson(name, age) {
  var obj = {}
  obj.name = name
  obj.age = age
  return obj
}







```

### 面向对象OOP

```javascript
/**
 * JS是一门编程语言（具备编程思想）
 *  【面向对象】
 *      JS、Java、PHP 、C#..
 *  【面向过程】
 *      C
 * 
 * 面向对象编程，需要我们掌握：” 对象、类、实例“、的概念
 *    对象： 万物皆对象
 *    类： 对象具体细分 （按照功能特点进行分类： 大类、小类）
 *    实例： 类中具体的一个事物 （拿出类别中的具体一个实例进行研究，那么当前类别下的其它实例也具备这些特点和特征）
 * 
 * 
 * JS就是基于面向对象设计和开发出来的语言，我们学习和实战的时候也要按照面相对象的思想去体会和理解
 */

 // => JS中的内置类




 /**
  * 基于构造函数创建自定义类(constructor)
  *  1、在普通函数执行的基础上”new xxx()“ ,这样就不是普通函执行了，而是构造函数执行，当前的函数名称之为”类名” 接收返回的实例
  *   2、 自己的创建的类型嗲一个单词大写
  * 3、这种构造函数设计模式执行，主要用于组件、类库、插件、框架等的封装，平时编写业务的逻辑一般不这样处理
  */

  function Fn() {

  }
  new fn();
  console.log(f)

  /**
   * JS中创建值两种方式
   * 1、字面表达式
   * 2、构造函数
   */
// 两种方式创建出来的没有区别

// => 基本数据累心基于两种方式创建出来的值是不一样的
// => 基于字面量方式创建出来的是基本类型值
// => 基于构造函数  引用类型的值
var n = 12
var n2 = new Number(13)


/// ===============
function Fn(name,age) {
  var n = 10
  this.name= name
  this.age = age + n

}
// => 普通函数执行，
// 1、形成一个私有的作用
// 2、形参赋值
// 3、变量提升
// 4、代码执行
// 5、栈内存释放问题
Fn();

//=> 构造函数执行
var f = new Fn('ddd',10)
// 1、向普通函数一样，形成一个私有的作用（栈内存）
//   私有变量{
//     形参赋值
//     变量提升
//   }
// 2、【构造函数独有的 】 -- 在JS代码自上而下执行之前，首先在当前形成的私有的栈中创建一个对象（创建一个堆内存，暂时不存储任何的东西），并且让函数中的执行主体（this）
// 执行这个新的堆内存（this===创建的对象）
// 3、代码开始自上而下执行
// 4、【构造函数独有的 】 代码执行完成，把之前创建的堆内存地址返回（浏览器默认返回）

/**
 * 构造函数不写return 浏览会默认返回创建的实例
 * 但是如果我们自己写了实例
 *  1、return 是一个基本知识，返回的结果依然是类的实例，没有影响
 * 2、如果返回的引用值，则会把默认返回的实例覆盖，此时接收的结果就不再是那个实例了
 * 
 * => 构造函数执行的时候，尽量减少return的使用个，防止覆盖实例
 */

function Fn() {
  var n = 10;
  this.m  = n;
  return '哈哈'
  // return {
  //   name: '哈哈'
  // }
}
var f = new Fn();
console.log(f.m)


1 instanceof Number // false
Number(1) instanceof Number // false
new Number(1) instanceof Number // true

// hasOwnProperty : // 检测当前属性是否为对象的私有属性
// in： 私有或者公有的
```

### 原型和原型链机制
```javascript

/**
 * 原型（prototype）、原型链（__proto__）
 * 
 * [函数] 
 *    普通函数、类、（所有的类： 内置类，自己创建的类）
 * [对象]
 *    普通对象、数组、正则、Math、
 *    实例是对象类型的（除了基本类型的字面量创建的值）
 *    prototype的值也是对象类型
 *    函数也是对象类型
 * 
 * 
 * 1、所有的函数数据类型都天生自带一个属性： prototype(原型)，这个属性的值是一个对象，浏览器会默认给他开辟一个堆内存
 * 2、在浏览器给prototype开辟的堆内存当中，有一个天生自带的属性constructor，这个属性的存储的值是当前函数本身。
 * 3、每一个对象都有一个__proto__的属性，这个属性指向当前实例所属类的原型prototype(如果不能确定他是谁的实例，都是Object的实例)
 */
Array.prototype.constructor === Array // true

// 每一个类都把供实例调取的公共属性方法，存储到自己的原型上（原型prototype的作用就是存储一些公共属性和方法，供他的实例调取使用）


/**
 * 原型链： 它是一种估基于__proto__向上查找的机制，当我们操作实例的某个属性或者方法的时候，首先找自己空间中私有的属性或者方法
 *  1、找到了，则结束查找，使用自己私有的即可
 *  2、没找到，则基于__proto__找所属的原型 prototype，如果找到就用这个公有的，没找到基于原型上的__proto __继续向上查找，一致找到
 * Object。prototype位置，如果没有，操作的属性或者方法不存在
 */
```
