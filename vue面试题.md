1.说说你对 SPA 单页面的理解，它的优缺点分别是什么？

|           |    多页应用模式MPA | 单页引用模式 SPA  |
| :-------- | --------:| :--:   |
| 应用组成   | 由多个完整页面构成    |  一个外壳页面和多个页面片段构成 |
| 跳转方式   |   页面之间的跳转是从一个页面跳转到另一个页面  |  页面片段之间的跳转是把一个页面片段删除或者隐藏，加载另一个页面片段并显示出来。这是片段之间的模拟跳转，并没有真正的离开壳页面 |
| 刷新方式| 整页刷新| 页面片段刷新 |
| 跳转后公共资源是否重新加载| 是 | 否 |
| URL模式 | http://xxx/page1.html http://xxx/page2.html | http://xxx/shell.html#page1 http://xxx/shell.html#page2 | 
| 用户体验 | 页面间切换加载慢， 不流畅， 用户体验差， 特别是在移动端设备上 | 页面片段间的切换块，用户体验好，包括在移动设备上 | 
| 能否实现转场动画 | 无法实现 | 容易实现 |
| 页面间传递数据 | 依赖URL，cookie 或者localStorage ，实现麻烦 | 因为在一个页面内，页面片段间传递数据很容易实现 | 
| 搜索引擎优化（SEO） | 可以直接做 | 需要单独方案做 |
| 特别适用的范围 | 需要对搜索引擎友好的网站 | 对体验要求高的应用， 特别是移动应用| 
| 开发难度 | 低一些，框架选择容易 | 高一些， 需要专门的框架来降低这种模式的开发难度  | 

 结论： 单页应用模式由于很多的好处们已经是web应用开发的潮流，特别使用应用开发 

2.vue-router 有哪几种导航守卫?

```javascript
全局守卫：
- router.beforeEach 全局前置守卫 进入路由之前
- router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用
- router.afterEach 全局后置钩子 进入路由之后

路由独享守卫：
- beforeEnter

路由组件内守卫:
- beforeRouteEnter 进入路由前, 在路由独享守卫后调用，不能获取组件实例this，组件实例还没被创建
- beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用
- beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用

router.beforeEach((to, from, next) => {
  // ...
  // next()  next(false)  next('/')
});

beforeRouteEnter(to, from, next) {
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
}

```

3. 真实项目中的权限校验
```javascript
/**
 * 权限校验
 *    1、登陆态的校验
 *      -> 路由的 beforeEach (登录态存储在vuex中)
 *      -> 向服务器发送请求
 *          + 登陆的时候，登陆成功后会在vuex中存储已经登陆  isLogin
 *          + 为了防止页面刷新过程中vuex存储信息消失，服务器是纪录登录态的
 *                + 会话方式  cookie session
 *                + token方式  JWT 生成token ，客户端把token存储起来(本地)
 *    2、接口权限校验   token
 *    3、菜单/按钮/功能权限 [显示隐藏]
 *        -> 登陆成功从服务器获取用户的权限字段，存储在本地(本地存储[不安全，可以加密存储，本地权限更新不及时] / vuex 不存在安全问题，每次刷新从服务器拉一边存一边)
 *        -> 自定义指令  控制渲染还是不渲染 (不建议大家在组件内 v-if)
 *        -> 有的公司，客户端渲染的菜单，都是服务器返回的HTML
 *    4、不管是否有权限都能看，只不过点击会提示或者不让跳转路由，再或者跳转到指定的路由
 *        -> beforeEach 
 *        -> 组件内自己判断
 *    5、真正的数据权限
 *        -> 都是服务器处理的（保证绝对的安全性）
 * 
 */
```
根据权限控制是否允许进入路由
4. 谈谈你对 keep-alive 的了解？

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：

一般结合路由和动态组件一起使用，用于缓存组件；
提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；

对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。

### 虚拟dom 有什么好处和作用？

 首先什么是虚拟DOM， 简单来说是用JS对象纪录的一个DOM节点的副本。
 虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和
 
 **为什么虚拟 dom 会提高性能?** 
虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。

当DOM发生更改的时候，先用虚拟DOM进行diff， 算出最小差异，然后再修改真实DOM。
当用传统的方式修改DOM的时候，浏览器每次都会从构建DOM树开始从头到尾执行一遍流程，效率低。

1.用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
2.当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
3.把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。
4.把树形结构按照层级分解，只比较同级元素。

### DOM 的diff算法

Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速
更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。
更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快 